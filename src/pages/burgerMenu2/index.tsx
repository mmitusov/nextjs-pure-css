import sass1 from '@/styles/burgerMenu2.module.scss'

//Dynamic Humburger solution no JS

//Так как мы пытаемся создать, бургер меню без JS, то для того чтобы отслеживать состояние меню (открыто/закрыто)/
//можно воспользовать <input type='checkbox'/>. Если чекбокс горит - то открыто, нет - то закрыто.
//HTML-элемент <aside> представляет собой часть документа, чьё содержимое только косвенно связанно с основным содержимым документа.
//А в целом, <aside> ведет себя как обычный div
//Воспользуемся <aside> для создания бокового меню, чисто ради SEO.
//Тег <nav> используется для создания блоков навигации, ссылок, которые ведут на другие веб-страницы, или разделы текущей.
//Чтобы держать код чище, вместо 3-х импутов, мы воспользуемся только одним, а при помощи before/after, дополнительно добавим 2 недостающие елемента
//При чем before/after применим к контенту label. И получится: before, контент (в нашем случае input), after.
//И чтобы увидеть наши before/after, не забываем отобразить елменты как flex+column
//Чтобы отключить дефолтный вид для input и иметь возможность его стилизировать, воспользуемся: appearance: none;
//Так как мы хотим взаимодействовать с input только через родительский label, а не на прямую, то сперва отключим сам input: pointer-events: none;
//И причина по которой мы обернули input в label - потому что когда мы нажимаем на label, то он автоматически активирует input чекбокс для нас
//Проверить, срабатывает ли наш чекбокс, можно при помощи - .hamburgerBtn > input:checked {}
//И на его срабатывание будем прятать input: opacity: 0; width: 0;
//Но выше мы обращаемся только к input на checked ивент. А как же обращаться к before/after елементам на тот же ивент?
//Есть ли внутри hamburgerBtn елемент у которого input=checked? Если да, то выбери елемент ::before/after и примени к нему стили по вращению: 
//.hamburgerBtn:has(>input:checked)::before {}
//Теперь когда мы можем вращать before/after, то при помощи тригонометри, нам нужно подсчитать какая должна быть длина елементов, чтобы после поворота, они не вылазили за переделы родительской "коробки"
//Также при повороте любых елементов (в нашем случае before/after) важно понимать один концепт:
//1. Каждый елемент имеет какую-то ширину больше, чем 0px
//2. Поворачивая елемент относительно левого края (transform-origin: left center;), он поворачивается относительно его условного горизонтального центра (середины/половины его высоты).
//То есть, после поворота, верхний край елемента, больше не будет находиться в верхней части (на его старой позиции)
//Его верхняя часть сместиться и теперь будет распологаться на прошлой линии условного горизонтального центра (на середине/половине его высоты).
//Поэтому после поворота, елемент будет сползать и отображаться выше/ниже на: element_height/2 (50% от высоты)
//3. Поэтому после поворота, нам желательно компенсировать этот сдвиг и возвращать елементы на их позции, при помощи:
//translate: 0 $bar-height/-2;

const SaasLearninig1 = () => {
    return (
        <div className={`${sass1.container}`}>
            <label className={`${sass1.hamburgerBtn}`}>
                <input type='checkbox'/>
            </label>
            <aside className={`${sass1.sideBar}`}>
                <p>Content</p>
                <p>Content</p>
                <p>Content</p>
                <p>Content</p>
            </aside>
        </div>
    );
}
 
export default SaasLearninig1;