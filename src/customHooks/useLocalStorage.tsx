//При создании кастомного хука он обязательно должен начинатся на "use". Так как реакт тогда будет поничмать, что мы хотим создать свой хук и будет проверять его на ошибки как хук
//Кастомный хук, как минимум должен состоять хотя-бы из одного вложенного хука - useEffect.
//Он отвечает за то, чтобы наша логика срабатывала каждый раз при вызове хука (выступает тригером, по запуску всех функций/механизмов по работе с информацией)
//Также useEffect часто используется в тандеме с useState
//useState - используется если нам нужно работать с вводной информацией и возвращать результат ее обработки
//или когда нам нужно обновить компонент после каких либо операций с данными
//Данные из кастомного хука мы можем возвращать либо в виде массива (класический вид), либо объекта, либо переменной (не желательно)
//А при вызове хука на стороне компонента, мы также запрашиваем данную информацию либо в виде массива, либо объекта соответственно:
// const [data, setData] = useLocalStorage('name', '') - массив (выглядет как класический useState)
// const { data, loading, error } = useFetch('https://api.example.com/data') - объект
// const data = useWindowDimentions() - если хук возвращает единственную переменную
//Так же стоит заметить что кастомный хук не обязательно должен возвращать данные (например в случае с логером)
//Из это и состоит самая базовая логика кастомного хука, главной задачей которой просто является инкапсуляцию нужной нам логики для многократного ее использования в разных местах
//И при желании, эту базовую логику можно превращать в очень комплексные хуки для разных задач
//Пример комплексных хуков будет рассмотрен позже на других разных примерах 
//Вот пример полезной логики которую было бы полезно инкапсулировать в кастомных хуках:
//LogerHook, ClickOutsideBurgerEventHook, GetWindowDimentionsHook, SetLocalStorageHook etc.

//Example from Web Dev Simplified
import { useEffect, useState } from "react";

//Если в Local Storage хранятся данные - забираем их
//Если нет - просто возвращаем изначально вводные данные
//P.S. TS мы не можем написать - JSON.parse(localStorage.getItem(key))
//Так как TS ругается, что возможно прийдется парсить null и это может привести к ошибке
//Поэтому данная логика разделена по примеру ниже
function getSavedValue (key: string, initialValue: any) {
    const savedValue = localStorage.getItem(key);
    if (savedValue) {
      return JSON.parse(savedValue);
    }

    return initialValue;
}

const useLocalStorage = (key:string, initialValue:any) => {
    const [data, setData] = useState(() => {
        return getSavedValue(key, initialValue)
    })

    useEffect(() => {
        localStorage.setItem(key, JSON.stringify(data))
    }, [data])

    return [data, setData]
}
 
export default useLocalStorage;
